---
description: CLI implementation standards for zerv including core commands, pipeline architecture, argument structures, and format validation patterns
globs: **/*.rs,**/src/cli/**/*.rs,**/tests/**/*.rs
alwaysApply: true
---

# CLI Implementation Standards

## Core Commands

### `zerv version [OPTIONS]`

Main version processing pipeline with composable operations.

### `zerv check <version> [OPTIONS]`

Validation-only command for version strings.

## Pipeline Architecture

```
Input → Version Object → Zerv Object → Transform → Output Version Object → Display
```

## Key Implementation Patterns

### Version Command Args Structure

```rust
#[derive(Parser)]
struct VersionArgs {
    version: Option<String>,
    #[arg(long, default_value = "git")]
    source: String,
    #[arg(long, default_value = "zerv-default")]
    schema: String,
    #[arg(long)]
    schema_ron: Option<String>,
    #[arg(long)]
    output_format: Option<String>,
}
```

### Check Command Args Structure

```rust
#[derive(Parser)]
struct CheckArgs {
    version: String,
    #[arg(long)]
    format: Option<String>,  // pep440, semver, auto-detect (default)
}
```

### Core Pipeline Function

```rust
pub fn run_version_pipeline(args: VersionArgs) -> Result<String> {
    // 1. Get VCS data
    let vcs_data = detect_vcs(current_dir())?.get_vcs_data()?;

    // 2. Convert to ZervVars
    let vars = vcs_data_to_zerv_vars(vcs_data)?;

    // 3. Apply schema and output format
    match args.output_format.as_deref() {
        Some("pep440") => Ok(PEP440::from_zerv(&vars)?.to_string()),
        Some("semver") => Ok(SemVer::from_zerv(&vars)?.to_string()),
        _ => Ok(vars.to_string()),
    }
}
```

## State-Based Versioning Tiers

**Tier 1** (Tagged, clean): `major.minor.patch`
**Tier 2** (Distance, clean): `major.minor.patch.post<distance>+branch.<commit>`
**Tier 3** (Dirty): `major.minor.patch.dev<timestamp>+branch.<commit>`

## Format Flag Validation Pattern

```rust
// Error if conflicting format flags used
if args.format.is_some() && (args.input_format.is_some() || args.output_format.is_some()) {
    return Err(ZervError::ConflictingFlags(
        "Cannot use --format with --input-format or --output-format".to_string()
    ));
}
```

## Check Command Auto-Detection Pattern

```rust
fn run_check_command(args: CheckArgs) -> Result<()> {
    match args.format.as_deref() {
        Some("pep440") => {
            PEP440::parse(&args.version)?;
            println!("✓ Valid PEP440 version");
        }
        Some("semver") => {
            SemVer::parse(&args.version)?;
            println!("✓ Valid SemVer version");
        }
        None => {
            // Auto-detect format
            let pep440_valid = PEP440::parse(&args.version).is_ok();
            let semver_valid = SemVer::parse(&args.version).is_ok();

            match (pep440_valid, semver_valid) {
                (true, false) => println!("✓ Valid PEP440 version"),
                (false, true) => println!("✓ Valid SemVer version"),
                (true, true) => {
                    println!("✓ Valid PEP440 version");
                    println!("✓ Valid SemVer version");
                }
                (false, false) => return Err(ZervError::InvalidVersion(args.version)),
            }
        }
        Some(format) => return Err(ZervError::UnknownFormat(format.to_string())),
    }
    Ok(())
}
```

## Essential CLI Options

### Input Sources

-   `--source git` (default) - Auto-detect Git
-   `--source string <version>` - Parse version string

### Schema Control

-   `--schema zerv-default` (default) - Tier-aware schema
-   `--schema-ron <ron>` - Custom RON schema

### Output Control

-   `--output-format <format>` - Target format: pep440, semver
-   `--output-template <template>` - Custom template string
-   `--output-prefix [prefix]` - Add prefix (defaults to "v")

## Constants Usage

**MANDATORY: Always use constants instead of bare strings**

### Field Names
- Use `fields::MAJOR` instead of `"major"`
- Use `fields::MINOR` instead of `"minor"`
- Use `fields::PATCH` instead of `"patch"`
- Use `fields::EPOCH` instead of `"epoch"`
- Use `fields::PRE_RELEASE` instead of `"pre_release"`
- Use `fields::POST` instead of `"post"`
- Use `fields::DEV` instead of `"dev"`
- Use `fields::DISTANCE` instead of `"distance"`
- Use `fields::DIRTY` instead of `"dirty"`
- Use `fields::BUMPED_BRANCH` instead of `"bumped_branch"`
- Use `fields::BUMPED_COMMIT_HASH` instead of `"bumped_commit_hash"`
- Use `fields::LAST_COMMIT_HASH` instead of `"last_commit_hash"`
- Use `fields::LAST_TIMESTAMP` instead of `"last_timestamp"`
- Use `fields::LAST_BRANCH` instead of `"last_branch"`

### Format Names
- Use `formats::SEMVER` instead of `"semver"`
- Use `formats::PEP440` instead of `"pep440"`
- Use `formats::ZERV` instead of `"zerv"`
- Use `formats::AUTO` instead of `"auto"`

### Source Names
- Use `sources::GIT` instead of `"git"`
- Use `sources::STDIN` instead of `"stdin"`

### Schema Names
- Use `schema_names::ZERV_STANDARD` instead of `"zerv-standard"`
- Use `schema_names::ZERV_CALVER` instead of `"zerv-calver"`

## Benefits of Using Constants

1. **Type Safety**: Compile-time checking for typos
2. **Refactoring**: Easy to rename fields across codebase
3. **Consistency**: Single source of truth for field names
4. **IDE Support**: Better autocomplete and navigation
5. **Maintenance**: Changes in one place affect all usage

## Anti-Patterns to Avoid

❌ **DON'T: Use bare strings**
```rust
match field_name.as_str() {
    "major" => // BAD
    "minor" => // BAD
    "patch" => // BAD
}
```

✅ **DO: Use constants**
```rust
match field_name.as_str() {
    fields::MAJOR => // GOOD
    fields::MINOR => // GOOD
    fields::PATCH => // GOOD
}
```

## Validation

When user mentions:
- "check constants usage"
- "find bare strings"
- "audit string literals"
- "constant compliance check"

→ Search codebase for violations:
- Bare string literals in match statements
- Hardcoded field names
- Magic strings in validation logic
- String literals that should be constants
